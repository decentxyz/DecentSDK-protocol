// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/*
 ______   _______  _______  _______  _       _________
(  __  \ (  ____ \(  ____ \(  ____ \( (    /|\__   __/
| (  \  )| (    \/| (    \/| (    \/|  \  ( |   ) (
| |   ) || (__    | |      | (__    |   \ | |   | |
| |   | ||  __)   | |      |  __)   | (\ \) |   | |
| |   ) || (      | |      | (      | | \   |   | |
| (__/  )| (____/\| (____/\| (____/\| )  \  |   | |
(______/ (_______/(_______/(_______/|/    )_)   )_(

*/

import '@openzeppelin/contracts/proxy/utils/Initializable.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/access/AccessControl.sol';
import '@openzeppelin/contracts/security/Pausable.sol';
import '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

import './extensions/ERC1155Hooks.sol';
import './storage/SeriesConfig.sol';
import './utils/Splits.sol';
import './utils/OperatorFilterer.sol';
import './interfaces/ITokenWithBalance.sol';
import './utils/Version.sol';

/**
 * @title DCNT1155
 * @dev An implementation of the ERC1155 multi-token standard.
 */
 contract DCNT1155 is
  ERC1155Hooks,
  Initializable,
  Ownable,
  AccessControl,
  Pausable,
  Splits,
  OperatorFilterer,
  Version(1)
{
  /*
   * @dev The name of the ERC-1155 contract.
   */
  string private _name;

  /*
   * @dev The symbol of the ERC-1155 contract.
   */
  string private _symbol;

  /*
   * @dev The base URI used to generate the URI for individual tokens.
   */
  string private _uri;

  /*
   * @dev The URI for the contract metadata.
   */
  string private _contractURI;

  /*
   * @dev The royalty fee in basis points (1/100th of a percent).
   */
  uint256 public royaltyBPS;

  /*
   * @dev The address that will receive payouts when withdrawing funds.
   * Use 0x0 to default to the contract owner.
   */
  address public payoutAddress;

  /*
   * @dev Whether the tokens are soulbound and cannot be transferred.
   */
  bool public isSoulbound;

  /**
   * @dev An array of droplet configurations defining each token with the series.
   * Adding a droplet creates a new token with a token ID equal to its index in this array.
   */
  Droplet[] public droplets;

  /*
   * @dev Mapping of token ID to the total number of tokens in circulation for that ID.
   */
  mapping(uint256 => uint256) public totalSupply;

  /*
   * @dev The address of the ChainLink price feed oracle to convert native currency to USD.
   */
  AggregatorV3Interface public currencyOracle;

  /*
   * @dev The address of the 0xSplits contract for generating split wallets.
   */
  address public splitMain;

  /*
   * @dev The address of the split wallet generated by the 0xSplits contract.
   */
  address public splitWallet;

  /**
   * @dev Checks whether the caller has the required minimum balance to pass through token gate.
   * @param tokenId The ID of the token to check.
   * @param isPresale A boolean indicating whether the sale type for is presale or primary sale.
   */
  modifier verifyTokenGate(uint256 tokenId, bool isPresale) {
    TokenGateConfig memory tokenGate = droplets[tokenId].tokenGate;
    if (tokenGate.tokenAddress != address(0)
      && (tokenGate.saleType == SaleType.ALL ||
          isPresale && tokenGate.saleType == SaleType.PRESALE) ||
          !isPresale && tokenGate.saleType == SaleType.PRIMARY) {
            require(ITokenWithBalance(tokenGate.tokenAddress).balanceOf(msg.sender) >= tokenGate.minBalance, 'do not own required token');
    }
    _;
  }

  /**
   * @dev Restricts access to only addresses with the DEFAULT_ADMIN_ROLE.
   */
  modifier onlyAdmin() {
    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "onlyAdmin");
    _;
  }

  /**
   * @dev Initializes the contract with the specified parameters.
   * @param _owner The owner of the contract.
   * @param _config The configuration for the contract.
   * @param _droplets The droplet configurations for the initial tokens.
   * @param _splitMain The 0xSplits contract address.
   */
  function initialize(
    address _owner,
    SeriesConfig memory _config,
    Droplet[] memory _droplets,
    address _splitMain
  ) public initializer {
    _transferOwnership(_owner);
    _grantRole(DEFAULT_ADMIN_ROLE, _owner);
    _name = _config.name;
    _symbol = _config.symbol;
    _uri = _config.metadataURI;
    _contractURI = _config.contractURI;
    royaltyBPS = _config.royaltyBPS;
    payoutAddress = _config.payoutAddress;
    isSoulbound = _config.isSoulbound;
    currencyOracle = AggregatorV3Interface(_config.currencyOracle);
    splitMain = _splitMain;

    uint256 length = _droplets.length;
    for (uint i = 0; i < length; i++) {
      _addDroplet(_droplets[i]);
    }
  }

  /**
   * @dev Returns the name of the contract.
   */
  function name() external view returns (string memory) {
    return _name;
  }

  /**
   * @dev Returns the symbol of the contract.
   */
  function symbol() external view returns (string memory) {
    return _symbol;
  }

  /**
   * @dev Returns the URI for a given token ID.
   * A single URI is returned for all token types as defined in EIP-1155's token type ID substitution mechanism.
   * Clients should replace `{id}` with the actual token type ID when calling the function.
   * @dev unused @param tokenId ID of the token to retrieve the URI for.
   */
  function uri(uint256) public view override returns (string memory) {
    return _uri;
  }

  /**
   * @dev Internal function to set the URI for all token IDs.
   * @param uri_ The URI for token all token IDs.
   */
  function _setURI(string memory uri_) private {
    _uri = uri_;
  }

  /**
   * @dev Set the URI for all token IDs.
   * @param uri_ The URI for token all token IDs.
   */
  function setURI(string memory uri_) external onlyAdmin {
    _uri = uri_;
  }

  /**
   * @dev Returns the URI of the contract metadata.
   */
  function contractURI() external view returns (string memory) {
    return _contractURI;
  }

  /**
   * @dev Sets the URI of the contract metadata.
   * @param contractURI_ The URI of the contract metadata.
   */
  function setContractURI(string memory contractURI_) external onlyAdmin {
    _contractURI = contractURI_;
  }

  /**
   * @dev Adds a single droplet to the droplet.
   * @param droplet The droplet configuration to add.
   */
  function _addDroplet(Droplet memory droplet) internal {
    droplets.push(Droplet({
      hasAdjustableCap: droplet.hasAdjustableCap,
      maxTokens: droplet.maxTokens,
      tokenPrice: droplet.tokenPrice,
      maxTokensPerOwner: droplet.maxTokensPerOwner,
      presaleMerkleRoot: droplet.presaleMerkleRoot,
      presaleStart: droplet.presaleStart,
      presaleEnd: droplet.presaleEnd,
      saleStart: droplet.saleStart,
      saleEnd: droplet.saleEnd,
      tokenGate: droplet.tokenGate
    }));
  }

  /**
   * @dev Adds the specified droplets to the droplet series, creating new token IDs.
   * @param _droplets The droplets configurations to add.
   */
  function addDroplets(Droplet[] memory _droplets) external onlyAdmin {
    uint256 length = _droplets.length;
    for (uint i = 0; i < length; i++) {
      _addDroplet(_droplets[i]);
    }
  }

  /**
   * @dev Updates the droplet configuration for the specified token IDs.
   * @param _tokenIds The IDs of the tokens to update.
   * @param _droplets The updated droplet configurations for the specified token IDs.
   */
  function setDroplets(uint256[] calldata _tokenIds, Droplet[] calldata _droplets) external onlyAdmin {
    uint256 length = _droplets.length;
    require(length == _tokenIds.length, 'uneven arrays');
    for (uint i = 0; i < length; i++) {
      uint256 tokenId = _tokenIds[i];
      require(tokenId < droplets.length, 'nonexistent token');
      Droplet memory _droplet = _droplets[i];
      Droplet storage droplet = droplets[tokenId];

      if ( droplet.hasAdjustableCap == false ) {
        require(!_droplet.hasAdjustableCap, 'caps are locked');
      }

      if ( droplet.maxTokens != _droplet.maxTokens ) {
        require(droplet.hasAdjustableCap, 'cannot adjust size of this collection');
        require(totalSupply[tokenId] <= _droplet.maxTokens, 'cannot decrease cap');
      }

      droplet.hasAdjustableCap = _droplet.hasAdjustableCap;
      droplet.maxTokens = _droplet.maxTokens;
      droplet.tokenPrice = _droplet.tokenPrice;
      droplet.maxTokensPerOwner = _droplet.maxTokensPerOwner;
      droplet.presaleMerkleRoot = _droplet.presaleMerkleRoot;
      droplet.presaleStart = _droplet.presaleStart;
      droplet.presaleEnd = _droplet.presaleEnd;
      droplet.saleStart = _droplet.saleStart;
      droplet.saleEnd = _droplet.saleEnd;
    }
  }

  /**
   * @dev Gets the current price for the specified token. If a currency oracle is set,
   * the price is calculated in native currency using the oracle exchange rate.
   * @param tokenId The ID of the token to get the price for.
   * @return The current price of the specified token.
   */
  function tokenPrice(uint256 tokenId) public view returns (uint256) {
    if ( address(currencyOracle) != address(0) ) {
      uint256 decimals = currencyOracle.decimals();
      (
          /* uint80 roundID */,
          int price,
          /*uint startedAt*/,
          /*uint timeStamp*/,
          /*uint80 answeredInRound*/
      ) = currencyOracle.latestRoundData();

      uint256 exchangeRate = decimals <= 18
        ? uint256(price) * (10 ** (18 - decimals))
        : uint256(price) / (10 ** (decimals - 18));

      return droplets[tokenId].tokenPrice * (10 ** 18) / exchangeRate;
    }

    return droplets[tokenId].tokenPrice;
  }

  /**
   * @dev Mints a specified number of tokens to a specified address.
   * @param tokenId The ID of the token to mint.
   * @param to The address to which the minted tokens will be sent.
   * @param quantity The quantity of tokens to mint.
   */
  function mint(uint256 tokenId, address to, uint256 quantity)
    external
    payable
    verifyTokenGate(tokenId, false)
    whenNotPaused
  {
    Droplet memory droplet = droplets[tokenId];
    uint256 supply = totalSupply[tokenId];
    require(block.timestamp >= droplet.saleStart && block.timestamp <= droplet.saleEnd, "Sales are not active.");
    require(
      supply + quantity <= droplet.maxTokens,
      "Purchase would exceed max supply"
    );
    require(supply <= droplet.maxTokens, "SOLD OUT");
    uint256 totalPrice = tokenPrice(tokenId) * quantity;
    require(msg.value >= totalPrice, "Insufficient funds");
    require(balanceOf[to][tokenId] + quantity <= droplet.maxTokensPerOwner, "Exceeded max number per owner");

    _mint(to, tokenId, quantity, '');
    totalSupply[tokenId] += quantity;

    if (msg.value > totalPrice) {
        (bool success, ) = payable(msg.sender).call{value: msg.value - totalPrice}("");
        require(success, "Refund failed");
    }
  }

  /**
   * @dev Burns a specified quantity of tokens from the caller's account.
   * @param tokenId The ID of the token to burn.
   * @param quantity The quantity of tokens to burn.
   */
  function burn(uint256 tokenId, uint256 quantity) external {
    require(balanceOf[msg.sender][tokenId] >= quantity, 'Burn exceeds owned tokens');
    _burn(msg.sender, tokenId, quantity);
    totalSupply[tokenId] -= quantity;
  }

  /**
   * @dev Mints a specified token to multiple recipients as part of an airdrop.
   * @param tokenId The ID of the token to mint.
   * @param recipients The list of addresses to receive the minted tokens.
   */
  function mintAirdrop(uint256 tokenId, address[] calldata recipients) external onlyAdmin {
    uint256 airdrops = recipients.length;
    require(totalSupply[tokenId] + airdrops <= droplets[tokenId].maxTokens,
      "Purchase would exceed max supply"
    );

    unchecked {
      for (uint i = 0; i < airdrops; i++) {
        address to = recipients[i];
        _mint(to, tokenId, 1, '');
      }
    }
    totalSupply[tokenId] += airdrops;
  }

  /**
   * @dev Mints a specified number of tokens to the presale buyer address.
   * @param tokenId The ID of the token to mint.
   * @param quantity The quantity of tokens to mint.
   * @param maxQuantity The maximum quantity of tokens that can be minted.
   * @param pricePerToken The price per token in wei.
   * @param merkleProof The Merkle proof verifying that the presale buyer is eligible to mint tokens.
   */
  function mintPresale(
    uint256 tokenId,
    uint256 quantity,
    uint256 maxQuantity,
    uint256 pricePerToken,
    bytes32[] calldata merkleProof
  )
    external
    payable
    verifyTokenGate(tokenId, true)
    whenNotPaused
  {
    Droplet memory droplet = droplets[tokenId];
    require (block.timestamp >= droplet.presaleStart && block.timestamp <= droplet.presaleEnd, 'not presale');
    uint256 supply = totalSupply[tokenId];
    require(
      supply + quantity <= droplet.maxTokens,
      "Purchase would exceed max supply"
    );
    require (MerkleProof.verify(
        merkleProof,
        droplet.presaleMerkleRoot,
        keccak256(
          abi.encodePacked(msg.sender,maxQuantity,pricePerToken)
        )
      ), 'not approved');

    require(msg.value >= (pricePerToken * quantity), "Insufficient funds");
    require(balanceOf[msg.sender][tokenId] + quantity <= maxQuantity, 'minted too many');
    _mint(msg.sender, tokenId, quantity, '');
  }

  /**
   * @dev Pauses public minting.
   */
  function pause() external onlyAdmin {
    _pause();
  }

  /**
   * @dev Unpauses public minting.
   */
  function unpause() external onlyAdmin {
    _unpause();
  }

  /**
   * @dev Sets the payout address to the specified address.
   * Use 0x0 to default to the contract owner.
   * @param _payoutAddress The address to set as the payout address.
   */
  function setPayoutAddress(address _payoutAddress) external onlyAdmin {
    payoutAddress = _payoutAddress;
  }

  /**
   * @dev Withdraws the balance of the contract to the payout address or the contract owner.
  */
  function withdraw() external {
    require(
      _getSplitWallet() == address(0),
      "Cannot withdraw with an active split"
    );

    address to = payoutAddress != address(0) ? payoutAddress : owner();
    (bool success, ) = payable(to).call{value: address(this).balance}("");
    require(success, "Could not withdraw");
  }

  function _getSplitMain() internal virtual override returns (address) {
    return splitMain;
  }

  function _getSplitWallet() internal virtual override returns (address) {
    return splitWallet;
  }

  function _setSplitWallet(address _splitWallet) internal virtual override {
    splitWallet = _splitWallet;
  }

  /**
   * @dev Returns the royalty recipient and amount for a given sale price.
   * @param tokenId The ID of the token being sold.
   * @param salePrice The sale price of the token.
   * @return receiver The address of the royalty recipient.
   * @return royaltyAmount The amount to be paid to the royalty recipient.
   */
  function royaltyInfo(uint256 tokenId, uint256 salePrice)
    external
    view
    returns (address receiver, uint256 royaltyAmount)
  {
    require(tokenId < droplets.length, 'nonexistent token');

    if (splitWallet != address(0)) {
      receiver = splitWallet;
    } else if ( payoutAddress != address(0) ) {
      receiver = payoutAddress;
    } else {
      receiver = owner();
    }

    uint256 royaltyPayment = (salePrice * royaltyBPS) / 100_00;

    return (receiver, royaltyPayment);
  }

  /**
   * @dev Returns true if the contract supports the given interface (ERC2981 or ERC1155),
   * as specified by interfaceId, false otherwise.
   * @param interfaceId The interface identifier, as specified in ERC-165.
   * @return True if the contract supports interfaceId, false otherwise.
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(ERC1155, AccessControl)
    returns (bool)
  {
    return
      interfaceId == 0x2a55205a || // ERC165 interface ID for ERC2981.
      AccessControl.supportsInterface(interfaceId) ||
      ERC1155.supportsInterface(interfaceId);
  }

  /**
   * @dev Updates the operator filter registry with the specified subscription.
   * @param enable If true, enables the operator filter, if false, disables it.
   * @param operatorFilter The address of the operator filter subscription.
   */
  function updateOperatorFilter(bool enable, address operatorFilter) external onlyAdmin {
    address self = address(this);
    if (!operatorFilterRegistry.isRegistered(self) && enable) {
      operatorFilterRegistry.registerAndSubscribe(self, operatorFilter);
    } else if (enable) {
      operatorFilterRegistry.subscribe(self, operatorFilter);
    } else {
      operatorFilterRegistry.unsubscribe(self, false);
      operatorFilterRegistry.unregister(self);
    }
  }

  /**
   * @dev Hook that is called before any token transfer, including minting and burning.
   * It checks if the operator is allowed and enforces the "soulbound" rule if enabled.
   * @param from The address from which the tokens are being transferred (or 0x0 if minting).
   * @param to The address to which the tokens are being transferred (or 0x0 if burning).
   * @dev unused @param ids An array containing the identifiers of the tokens being transferred.
   * @dev unused @param amounts An array containing the amounts of tokens being transferred.
   */
  function _beforeTokenTransfers(
    address from,
    address to,
    uint256[] memory,
    uint256[] memory
  ) internal virtual override onlyAllowedOperator(from) {
    require (!isSoulbound || (from == address(0) || to == address(0)), 'soulbound');
  }

  /**
   * @dev Sets or revokes approval for a third party ("operator") to manage all of the caller's tokens.
   * @param operator The address of the operator to grant or revoke approval.
   * @param approved True to grant approval, false to revoke it.
   */
  function setApprovalForAll(
    address operator,
    bool approved
  ) public virtual override onlyAllowedOperatorApproval(operator) {
    super.setApprovalForAll(operator, approved);
  }
}
